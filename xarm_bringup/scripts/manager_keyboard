#! /usr/bin/env python3
# NOTE: Final version - A simple remote controller for the robot and recorder.

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped, Twist, Pose
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from std_msgs.msg import Float64MultiArray, Int32
import numpy as np
import sys, select, termios, tty, threading, time, subprocess, re
import transforms3d as t3d

settings = termios.tcgetattr(sys.stdin)

def getKey():
    tty.setraw(sys.stdin.fileno())
    select.select([sys.stdin], [], [], 0)
    key = sys.stdin.read(1)
    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
    return key

def call_ros2_service(activate_controllers, deactivate_controllers):
    service_name = '/controller_manager/switch_controller'
    service_type = 'controller_manager_msgs/srv/SwitchController'
    strictness = '2'
    activate_asap = 'true'
    command = f'ros2 service call {service_name} {service_type} "{{activate_controllers: [\\"{activate_controllers}\\"], deactivate_controllers: [\\"{deactivate_controllers}\\"], strictness: {strictness}, activate_asap: {activate_asap}}}"'
    try:
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
        match = re.search(r'response:\n(.*)', result.stdout, re.DOTALL)
        print(f"Service call for '{activate_controllers}':", match.group(1).strip())
    except subprocess.CalledProcessError as e:
        print(f"Error calling ROS 2 service: {e}")

msg = """
Teleop Controller (sends signals to recorder)
---------------------------
Operation:
 1. Run 'episode_recorder.py --data_dir your_folder' in a separate terminal.
 2. Run this script to control the robot and recording.

Controls:
   u    i    o
   j    k    l
        ,     

i/,: forward/backward | u/o: left/right | t/b: up/down
j/l: yaw              | k: stop moving  | g: gripper
r: respawn           | y: init pose

--- Recording ---
S: START episode | E: END and SAVE episode

CTRL-C or q to quit
"""

moveBindings = {
    'i': (0.1, 0, 0, 0), ',': (-0.1, 0, 0, 0),
    'u': (0, 0.1, 0, 0), 'o': (0, -0.1, 0, 0),
    't': (0, 0, 0.1, 0), 'b': (0, 0, -0.1, 0),
    'j': (0, 0, 0, 0.1), 'l': (0, 0, 0, -0.1),
}

class KeyboardTeleop(Node):
    def __init__(self):
        super().__init__('keyboard_teleop')

        # Publishers for robot control
        self.publisher_target_pose = self.create_publisher(PoseStamped, '/target_frame_raw', 10)
        self.publisher_gripper = self.create_publisher(Float64MultiArray, '/position_controller/commands', 10)
        self.publisher_respawn = self.create_publisher(Twist, '/respawn', 10)
        self.publisher_joint_init = self.create_publisher(JointTrajectory, '/joint_trajectory_controller/joint_trajectory', 1)

        # Publisher to send recording signals to the recorder node
        self.publisher_start_saving = self.create_publisher(Int32, '/start_episode_saving', 10)
        
        # Subscriber for current pose
        self.current_pose_subscriber = self.create_subscription(PoseStamped, '/current_pose', self.current_pose_callback, 10)
        
        self.current_pose = PoseStamped()
        self.is_gripper_open = True
        self.is_recording = False

        # Arm initialization components
        self.joint_state = JointTrajectory()
        self.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6']
        point = JointTrajectoryPoint()
        point.positions = [0.00148, 0.06095, 1.164, -0.00033, 1.122, -0.00093]
        point.time_from_start.sec = 3
        self.joint_state.points = [point]
        self.joint_state.joint_names = self.joint_names

    def current_pose_callback(self, msg):
        if self.current_pose.header.stamp.sec == 0:
            self.get_logger().info("Initial pose received. Ready.")
        self.current_pose = msg

    def initialize_arm_pose(self):
        self.get_logger().info("Moving arm to initial pose...")
        try:
            call_ros2_service('joint_trajectory_controller', 'cartesian_motion_controller')
            time.sleep(0.5)
            self.joint_state.header.stamp = self.get_clock().now().to_msg()
            self.publisher_joint_init.publish(self.joint_state)
            self.get_logger().info("Waiting for movement to complete...")
            time.sleep(3.5)
            call_ros2_service('cartesian_motion_controller', 'joint_trajectory_controller')
            self.get_logger().info("Arm is in initial pose.")
        except Exception as e:
            self.get_logger().error(f"Failed to initialize arm pose: {e}")

    def run(self):
        print(msg)
        while self.current_pose.header.stamp.sec == 0:
            self.get_logger().info("Waiting for initial pose from robot...", throttle_duration_sec=2)
            rclpy.spin_once(self, timeout_sec=0.5)
        
        target_pose = self.current_pose
        speed = 0.2
        turn = 0.5
        
        try:
            while rclpy.ok():
                # Process ROS Callbacks to get latest sensor data
                rclpy.spin_once(self, timeout_sec=0.01)
                
                key = getKey().lower()
                if key == '\x03' or key == 'q':
                    if self.is_recording:
                        self.get_logger().info("Stopping recording before quitting...")
                        self.publisher_start_saving.publish(Int32(data=0))
                    break
                
                # --- Recording Controls ---
                if key == 's':
                    self.get_logger().info("--- START EPISODE signal sent ---")
                    self.publisher_start_saving.publish(Int32(data=2))
                    self.is_recording = True
                    target_pose = self.current_pose # Reset target pose to current pose
                    # Send signal to save the very first frame
                    self.publisher_start_saving.publish(Int32(data=1))
                    continue
                elif key == 'e':
                    self.get_logger().info("--- END EPISODE signal sent ---")
                    self.publisher_start_saving.publish(Int32(data=0))
                    self.is_recording = False
                    continue
                elif key == 'y':
                    init_thread = threading.Thread(target=self.initialize_arm_pose)
                    init_thread.start()
                    continue

                # --- Robot Motion Controls ---
                moved = False
                if key in moveBindings:
                    target_pose.pose.position.x += moveBindings[key][0] * speed * 0.1
                    target_pose.pose.position.y += moveBindings[key][1] * speed * 0.1
                    target_pose.pose.position.z += moveBindings[key][2] * speed * 0.1
                    q = [target_pose.pose.orientation.w, target_pose.pose.orientation.x, target_pose.pose.orientation.y, target_pose.pose.orientation.z]
                    r, p, y = t3d.euler.quat2euler(q)
                    y += moveBindings[key][3] * turn * 0.1
                    new_q = t3d.euler.euler2quat(r, p, y)
                    target_pose.pose.orientation.w, target_pose.pose.orientation.x, target_pose.pose.orientation.y, target_pose.pose.orientation.z = new_q[0], new_q[1], new_q[2], new_q[3]
                    moved = True
                
                elif key == 'k': # Stop key restored
                    target_pose = self.current_pose
                    moved = True

                elif key == 'g':
                    msg_arr = Float64MultiArray()
                    msg_arr.data = [-0.01] if self.is_gripper_open else [0.0]
                    self.publisher_gripper.publish(msg_arr)
                    self.is_gripper_open = not self.is_gripper_open
                    moved = True
                
                elif key == 'r':
                    self.publisher_respawn.publish(Twist())

                # If recording and a move was made, send a "save frame" signal to the recorder
                if self.is_recording and moved:
                    self.publisher_start_saving.publish(Int32(data=1))

                target_pose.header.stamp = self.get_clock().now().to_msg()
                self.publisher_target_pose.publish(target_pose)

        finally:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)

def main(args=None):
    rclpy.init(args=args)
    keyboard_teleop = KeyboardTeleop()
    
    # Spin node in a separate thread to handle callbacks
    spin_thread = threading.Thread(target=rclpy.spin, args=(keyboard_teleop,))
    spin_thread.start()
    
    keyboard_teleop.run() # This is a blocking loop for keyboard input
    
    keyboard_teleop.destroy_node()
    rclpy.shutdown()
    spin_thread.join()

if __name__ == '__main__':
    main()