#! /usr/bin/env python3
# NOTE: Final version - Combines robust manual recording with arm initialization feature.

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Pose, PoseStamped, Twist
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from sensor_msgs.msg import Image
from std_msgs.msg import Float64MultiArray, Int32
from cv_bridge import CvBridge, CvBridgeError
import transforms3d as t3d
from ros2_numpy_tf import ros2numpy
from datetime import datetime
import numpy as np
import cv2
import os
import argparse
import sys
import select
import termios
import tty
import threading
import subprocess
import re
import time  # <-- [FIX] Missing time module import

settings = termios.tcgetattr(sys.stdin)

def getKey():
    tty.setraw(sys.stdin.fileno())
    select.select([sys.stdin], [], [], 0)
    key = sys.stdin.read(1)
    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
    return key

def call_ros2_service(activate_controllers, deactivate_controllers):
    service_name = '/controller_manager/switch_controller'
    service_type = 'controller_manager_msgs/srv/SwitchController'
    strictness = '2'
    activate_asap = 'true'
    command = f'ros2 service call {service_name} {service_type} "{{activate_controllers: [\\"{activate_controllers}\\"], deactivate_controllers: [\\"{deactivate_controllers}\\"], strictness: {strictness}, activate_asap: {activate_asap}}}"'
    try:
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
        match = re.search(r'response:\n(.*)', result.stdout, re.DOTALL)
        print(f"Service call for '{activate_controllers}':", match.group(1).strip())
    except subprocess.CalledProcessError as e:
        print(f"Error calling ROS 2 service: {e}")

def get_actions_from_observations_delta(observations):
    actions = []
    for i in range(len(observations) - 1):
        current_pose_6d = observations[i][:6]
        next_pose_6d = observations[i+1][:6]
        T_current = np.eye(4)
        T_current[:3, :3] = t3d.euler.euler2mat(current_pose_6d[3], current_pose_6d[4], current_pose_6d[5], 'sxyz')
        T_current[:3, 3] = current_pose_6d[:3]
        T_next = np.eye(4)
        T_next[:3, :3] = t3d.euler.euler2mat(next_pose_6d[3], next_pose_6d[4], next_pose_6d[5], 'sxyz')
        T_next[:3, 3] = next_pose_6d[:3]
        action_matrix = np.linalg.inv(T_current) @ T_next
        translation = action_matrix[:3, 3]
        rotation = t3d.euler.mat2euler(action_matrix[:3, :3], axes='sxyz')
        pose_6d = np.concatenate((translation, rotation))
        actions.append(f"[{', '.join(map(str, pose_6d))}]\n")
    actions.append('[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n')
    return actions

class EpisodeManager(Node):
    def __init__(self):
        super().__init__('episode_manager')
        
        self.robot_state_subscriber = self.create_subscription(
            Float64MultiArray, '/robot_state_7d', self.robot_state_callback, 10)

        self.publisher_joint_init = self.create_publisher(
            JointTrajectory, '/joint_trajectory_controller/joint_trajectory', 1)

        self.listener_thread = threading.Thread(target=self.start_keyboard_listener, daemon=True)
        self.listener_thread.start()
        
        self.get_logger().info("Episode Manager started.")

        self.is_recording = False
        self.latest_robot_state_7d = []
        self.episode_observations = []

        self.data_dir = os.path.expanduser("~/robo_imitate/collected_data")
        os.makedirs(self.data_dir, exist_ok=True)
        self.observations_file = None
        self.actions_file = None
        
        self.joint_state = JointTrajectory()
        self.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6']
        point = JointTrajectoryPoint()
        point.positions = [0.00148, 0.06095, 1.164, -0.00033, 1.122, -0.00093]
        point.time_from_start.sec = 3
        point.time_from_start.nanosec = 0
        self.joint_state.points = [point]
        self.joint_state.joint_names = self.joint_names

    def start_keyboard_listener(self):
        while rclpy.ok():
            key = getKey()
            if key == 't':
                self.start_recording()
            elif key == 'e':
                self.stop_and_save_episode()
            elif key == 'i':
                # Run the blocking function in a separate thread to not block the listener
                init_thread = threading.Thread(target=self.initialize_arm_pose)
                init_thread.start()
            elif key == 'q':
                self.get_logger().info('Quit key pressed. Shutting down.')
                rclpy.shutdown()
                break
            time.sleep(0.1)
            
    def initialize_arm_pose(self):
        self.get_logger().info("Moving arm to initial pose...")
        try:
            call_ros2_service('joint_trajectory_controller', 'cartesian_motion_controller')
            time.sleep(0.5)
            self.joint_state.header.stamp = self.get_clock().now().to_msg()
            self.publisher_joint_init.publish(self.joint_state)
            self.get_logger().info("Initial pose command sent. Waiting for movement to complete...")
            time.sleep(3.5)
            call_ros2_service('cartesian_motion_controller', 'joint_trajectory_controller')
            self.get_logger().info("Arm is in initial pose. Switched back to cartesian controller.")
        except Exception as e:
            self.get_logger().error(f"Failed to initialize arm pose: {e}")

    def robot_state_callback(self, msg):
        self.latest_robot_state_7d = list(msg.data)
        if self.is_recording:
            self.episode_observations.append(self.latest_robot_state_7d)
            if len(self.episode_observations) % 20 == 0:
                 self.get_logger().info(f"Recording... {len(self.episode_observations)} frames collected.")

    def start_recording(self):
        if self.is_recording:
            self.get_logger().warn("Already recording an episode.")
            return
        self.is_recording = True
        self.episode_observations = []
        episode_name = datetime.now().strftime("%Y_%m_%d_%H_%M_%S")
        observation_folder = os.path.join(self.data_dir, 'observations')
        action_folder = os.path.join(self.data_dir, 'actions')
        os.makedirs(observation_folder, exist_ok=True)
        os.makedirs(action_folder, exist_ok=True)
        obs_path = os.path.join(observation_folder, episode_name + '.txt')
        act_path = os.path.join(action_folder, episode_name + '.txt')
        self.observations_file = open(obs_path, "w")
        self.actions_file = open(act_path, "w")
        self.get_logger().info(f"--- Started Manual Recording for episode {episode_name} ---")

    def stop_and_save_episode(self):
        if not self.is_recording:
            self.get_logger().warn("Not currently recording."); return
        self.is_recording = False
        self.get_logger().info("--- Stopping Manual Recording ---")

        if not self.episode_observations:
            self.get_logger().warn("No observations were recorded. Nothing to save."); return
            
        for obs in self.episode_observations:
            self.observations_file.write(f"[{', '.join(map(str, obs))}]\n")
        
        self.get_logger().info("Calculating delta-pose actions...")
        actions = get_actions_from_observations_delta(self.episode_observations)
        self.actions_file.writelines(actions)

        self.observations_file.close(); self.actions_file.close()
        self.observations_file = None; self.actions_file = None
        
        self.get_logger().info(f"Episode saved. Frames: {len(self.episode_observations)}, Actions: {len(actions)}")

def main(args=None):
    msg = """
    Manual Episode Manager
    ---------------------------
    Press 't' to START recording.
    Press 'e' to STOP recording and save.
    Press 'i' to move the arm to the initial pose.
    Press 'q' to quit.
    """
    print(msg)
    rclpy.init(args=args)
    episode_manager = EpisodeManager()
    rclpy.spin(episode_manager)

    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
    episode_manager.destroy_node()

if __name__ == "__main__":
    main()